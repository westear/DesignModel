装饰器模式: 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式比生成子类更灵活。
demo1中SalesTicket 订单发票就是原有对象，发票的表头和页脚可以看成是装饰器

意图： 动态地给一个对象添加职责

问题：要使用的对象将执行所需的基本功能。但是可能需要为这个对象添加某些附加功能，这些功能可能发生在对象基础功能的之前或者之后。

实现：1.创建一个对象类来表示原类和要添加到这个类的新功能。
     2.在装饰类中，将对新功能的调用放在对紧随其后对象的调用之前或者之后，以获得正确的顺序。
     3.但对象调用链总是终于基础功能的对象类，比如demo1的 SalesTicket. (调用链可以放在一个Factory类或者配置类中)

优点:
    1.装饰类和被装饰类可以独立发展，而不会互相耦合。Component类无须知道Decorator类，Decorator类从外部扩展Component类的功能。
    2.装饰模式是继承关系的一个替代方案。不管装饰多少层，返回的始终是一个Component类，实现的还是is-a的关系。
    3.动态地扩展一个实现类的功能

缺点：
    调用链出现问题是较难排查具体是哪个装饰类出现问题，特别是调用链很长很复杂的时候

使用场景:
    1.扩展一个类的功能，或者给一个类添加附加功能
    2.需要动态增加或者撤销一个类的某些功能
    3.需要为一批兄弟类改装或者加装一些功能

